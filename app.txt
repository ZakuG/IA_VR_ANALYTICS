# app.py
from flask import Flask, render_template, request, jsonify, session, redirect, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
import pandas as pd
import numpy as np
from datetime import datetime
import json
from data_analytics import AnalizadorAvanzado

app = Flask(__name__)
app.config['SECRET_KEY'] = 'tu_clave_secreta_aqui'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///vr_analytics.db'

db = SQLAlchemy(app)
bcrypt = Bcrypt(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'

# Tabla de asociación para relación many-to-many entre Estudiante y Profesor
estudiante_profesor = db.Table('estudiante_profesor',
    db.Column('estudiante_id', db.Integer, db.ForeignKey('estudiante.id'), primary_key=True),
    db.Column('profesor_id', db.Integer, db.ForeignKey('profesor.id'), primary_key=True),
    db.Column('fecha_inscripcion', db.DateTime, default=datetime.utcnow)
)

# Modelos de Base de Datos
class Profesor(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    institucion = db.Column(db.String(200))
    fecha_registro = db.Column(db.DateTime, default=datetime.utcnow)
    reset_token = db.Column(db.String(100))
    reset_token_expiry = db.Column(db.DateTime)
    # Relación many-to-many con estudiantes
    estudiantes = db.relationship('Estudiante', secondary=estudiante_profesor, 
                                   backref=db.backref('profesores', lazy='dynamic'),
                                   lazy='dynamic')
    
    def get_id(self):
        return f"profesor_{self.id}"

class Estudiante(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    codigo = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True)
    password = db.Column(db.String(200))
    nivel_habilidad = db.Column(db.Integer, default=3)  # 1-5, default 3 (intermedio)
    fecha_registro = db.Column(db.DateTime, default=datetime.utcnow)
    reset_token = db.Column(db.String(100))
    reset_token_expiry = db.Column(db.DateTime)
    sesiones = db.relationship('Sesion', backref='estudiante', lazy=True)
    # Nota: profesores ahora es una relación many-to-many definida en Profesor
    
    def get_id(self):
        return f"estudiante_{self.id}"

class Sesion(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    estudiante_id = db.Column(db.Integer, db.ForeignKey('estudiante.id'), nullable=False)
    profesor_id = db.Column(db.Integer, db.ForeignKey('profesor.id'), nullable=True)  # Sesión vinculada a profesor
    maqueta = db.Column(db.String(100), nullable=False)
    tiempo_segundos = db.Column(db.Integer, nullable=False)
    puntaje = db.Column(db.Integer, nullable=False)
    fecha = db.Column(db.DateTime, default=datetime.utcnow)
    respuestas_detalle = db.Column(db.Text)  # JSON con respuestas
    interacciones_ia = db.Column(db.Integer, default=0)

@login_manager.user_loader
def load_user(user_id):
    if user_id.startswith('profesor_'):
        return Profesor.query.get(int(user_id.split('_')[1]))
    elif user_id.startswith('estudiante_'):
        return Estudiante.query.get(int(user_id.split('_')[1]))
    return None

# Clase para Análisis de Datos
class AnalizadorDatos:
    def __init__(self, sesiones):
        self.df = pd.DataFrame([{
            'estudiante_id': s.estudiante_id,
            'estudiante_nombre': s.estudiante.nombre,
            'maqueta': s.maqueta,
            'tiempo_segundos': s.tiempo_segundos,
            'puntaje': s.puntaje,
            'fecha': s.fecha,
            'interacciones_ia': s.interacciones_ia
        } for s in sesiones])
    
    def estadisticas_generales(self):
        """Calcula estadísticas descriptivas generales"""
        if self.df.empty:
            return {}
        
        def safe_value(value, default=0):
            """Convierte NaN a valor por defecto para JSON"""
            import math
            if value is None or (isinstance(value, float) and math.isnan(value)):
                return default
            return value
        
        return {
            'total_sesiones': len(self.df),
            'promedio_puntaje': safe_value(round(self.df['puntaje'].mean(), 2)),
            'promedio_tiempo': safe_value(round(self.df['tiempo_segundos'].mean(), 2)),
            'mediana_puntaje': safe_value(self.df['puntaje'].median()),
            'desviacion_puntaje': safe_value(round(self.df['puntaje'].std(), 2)),
            'tasa_aprobacion': safe_value(round((self.df['puntaje'] >= 3).sum() / len(self.df) * 100, 2)),
            'mejor_puntaje': safe_value(self.df['puntaje'].max()),
            'peor_puntaje': safe_value(self.df['puntaje'].min())
        }
    
    def analisis_por_maqueta(self):
        """Análisis detallado por tipo de maqueta"""
        if self.df.empty:
            return {}
        
        return self.df.groupby('maqueta').agg({
            'puntaje': ['mean', 'median', 'std', 'count'],
            'tiempo_segundos': ['mean', 'median'],
            'interacciones_ia': 'mean'
        }).round(2).to_dict()
    
    def correlaciones(self):
        """Análisis de correlaciones"""
        if self.df.empty:
            return {}
        
        import math
        
        correlacion_tiempo_puntaje = self.df['tiempo_segundos'].corr(self.df['puntaje'])
        correlacion_ia_puntaje = self.df['interacciones_ia'].corr(self.df['puntaje'])
        
        # Manejar NaN en correlaciones
        tiempo_puntaje_val = 0 if math.isnan(correlacion_tiempo_puntaje) else round(correlacion_tiempo_puntaje, 3)
        ia_puntaje_val = 0 if math.isnan(correlacion_ia_puntaje) else round(correlacion_ia_puntaje, 3)
        
        return {
            'tiempo_puntaje': tiempo_puntaje_val,
            'ia_puntaje': ia_puntaje_val,
            'interpretacion_tiempo': self._interpretar_correlacion(tiempo_puntaje_val),
            'interpretacion_ia': self._interpretar_correlacion(ia_puntaje_val)
        }
    
    def _interpretar_correlacion(self, valor):
        """Interpreta el valor de correlación"""
        abs_valor = abs(valor)
        if abs_valor < 0.3:
            fuerza = "débil"
        elif abs_valor < 0.7:
            fuerza = "moderada"
        else:
            fuerza = "fuerte"
        
        direccion = "positiva" if valor > 0 else "negativa"
        return f"Correlación {fuerza} {direccion}"
    
    def estudiantes_en_riesgo(self):
        """Identifica estudiantes que necesitan atención"""
        if self.df.empty:
            return []
        
        estudiantes_stats = self.df.groupby('estudiante_id').agg({
            'puntaje': 'mean',
            'tiempo_segundos': 'mean',
            'estudiante_nombre': 'first'
        }).reset_index()
        
        # Criterios de riesgo: promedio < 3 o tiempo muy alto/bajo
        promedio_tiempo = estudiantes_stats['tiempo_segundos'].mean()
        std_tiempo = estudiantes_stats['tiempo_segundos'].std()
        
        en_riesgo = estudiantes_stats[
            (estudiantes_stats['puntaje'] < 3) | 
            (estudiantes_stats['tiempo_segundos'] > promedio_tiempo + 2*std_tiempo) |
            (estudiantes_stats['tiempo_segundos'] < promedio_tiempo - 2*std_tiempo)
        ]
        
        return en_riesgo.to_dict('records')
    
    def tendencias_temporales(self):
        """Análisis de tendencias en el tiempo"""
        if self.df.empty:
            return {}
        
        self.df['fecha'] = pd.to_datetime(self.df['fecha'])
        tendencias = self.df.set_index('fecha').resample('D').agg({
            'puntaje': 'mean',
            'tiempo_segundos': 'mean'
        }).fillna(method='ffill').to_dict()
        
        return {
            'puntaje_diario': tendencias['puntaje'],
            'tiempo_diario': tendencias['tiempo_segundos']
        }
    
    def ranking_estudiantes(self, top_n=10):
        """Top estudiantes por rendimiento"""
        if self.df.empty:
            return []
        
        ranking = self.df.groupby(['estudiante_id', 'estudiante_nombre']).agg({
            'puntaje': 'mean',
            'tiempo_segundos': 'mean'
        }).reset_index()
        
        ranking['puntuacion_final'] = (
            ranking['puntaje'] * 0.7 + 
            (100 - ranking['tiempo_segundos']) * 0.3
        )
        
        return ranking.nlargest(top_n, 'puntuacion_final').to_dict('records')

# Rutas
@app.route('/')
def index():
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    return render_template('index.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        data = request.json
        tipo_usuario = data.get('tipo_usuario', 'profesor')
        hashed_password = bcrypt.generate_password_hash(data['password']).decode('utf-8')
        
        try:
            if tipo_usuario == 'profesor':
                usuario = Profesor(
                    nombre=data['nombre'],
                    email=data['email'],
                    password=hashed_password,
                    institucion=data.get('institucion', '')
                )
                db.session.add(usuario)
                db.session.commit()
                return jsonify({'success': True, 'message': 'Profesor registrado exitosamente'})
            
            elif tipo_usuario == 'estudiante':
                # Generar código de estudiante AUTOMÁTICAMENTE
                # Contar estudiantes existentes para generar código único
                contador = Estudiante.query.count() + 1
                codigo = f"EST{contador:04d}"  # Formato: EST0001, EST0002, etc.
                
                # Verificar que el código sea único (por si acaso)
                while Estudiante.query.filter_by(codigo=codigo).first():
                    contador += 1
                    codigo = f"EST{contador:04d}"
                
                # Profesor es opcional ahora - pueden inscribirse después
                profesor_id = None
                email_profesor = data.get('email_profesor')
                
                if email_profesor:
                    profesor = Profesor.query.filter_by(email=email_profesor).first()
                    if not profesor:
                        return jsonify({'success': False, 'message': 'Profesor no encontrado'}), 404
                    profesor_id = profesor.id
                
                usuario = Estudiante(
                    nombre=data['nombre'],
                    codigo=codigo,  # Código generado automáticamente
                    email=data['email'],
                    password=hashed_password,
                    nivel_habilidad=data.get('nivel_habilidad', 3),
                    profesor_id=profesor_id  # Puede ser None
                )
                db.session.add(usuario)
                db.session.commit()
                return jsonify({
                    'success': True, 
                    'message': 'Estudiante registrado exitosamente',
                    'codigo': codigo  # Retornar el código generado
                })
        
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 400
    
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.json
        
        # Buscar en profesores
        profesor = Profesor.query.filter_by(email=data['email']).first()
        if profesor and bcrypt.check_password_hash(profesor.password, data['password']):
            login_user(profesor)
            return jsonify({'success': True, 'tipo': 'profesor'})
        
        # Buscar en estudiantes
        estudiante = Estudiante.query.filter_by(email=data['email']).first()
        if estudiante and estudiante.password and bcrypt.check_password_hash(estudiante.password, data['password']):
            login_user(estudiante)
            return jsonify({'success': True, 'tipo': 'estudiante'})
        
        return jsonify({'success': False, 'message': 'Credenciales inválidas'}), 401
    
    return render_template('login.html')

@app.route('/forgot-password', methods=['GET', 'POST'])
def forgot_password():
    if request.method == 'POST':
        data = request.json
        email = data.get('email')
        
        # Buscar usuario (profesor o estudiante)
        profesor = Profesor.query.filter_by(email=email).first()
        estudiante = Estudiante.query.filter_by(email=email).first()
        
        usuario = profesor or estudiante
        
        if usuario:
            # Generar token simple (en producción usar algo más seguro)
            import secrets
            token = secrets.token_urlsafe(32)
            usuario.reset_token = token
            usuario.reset_token_expiry = datetime.utcnow() + pd.Timedelta(hours=1)
            db.session.commit()
            
            # En producción, enviar email con el token
            # Por ahora, retornar el token (solo para desarrollo)
            reset_link = url_for('reset_password', token=token, _external=True)
            return jsonify({
                'success': True, 
                'message': 'Se ha generado un enlace de recuperación',
                'reset_link': reset_link  # En producción, esto se enviaría por email
            })
        
        # Por seguridad, siempre retornar éxito aunque el email no exista
        return jsonify({'success': True, 'message': 'Si el email existe, recibirás instrucciones'})
    
    return render_template('forgot_password.html')

@app.route('/reset-password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    if request.method == 'POST':
        data = request.json
        new_password = data.get('password')
        
        # Buscar usuario por token
        profesor = Profesor.query.filter_by(reset_token=token).first()
        estudiante = Estudiante.query.filter_by(reset_token=token).first()
        
        usuario = profesor or estudiante
        
        if not usuario or usuario.reset_token_expiry < datetime.utcnow():
            return jsonify({'success': False, 'message': 'Token inválido o expirado'}), 400
        
        # Actualizar contraseña
        usuario.password = bcrypt.generate_password_hash(new_password).decode('utf-8')
        usuario.reset_token = None
        usuario.reset_token_expiry = None
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Contraseña actualizada exitosamente'})
    
    return render_template('reset_password.html', token=token)

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))

@app.route('/dashboard')
@login_required
def dashboard():
    # Redirigir según tipo de usuario
    if isinstance(current_user, Profesor):
        return render_template('dashboard.html', profesor=current_user)
    else:
        return render_template('dashboard_estudiante.html', estudiante=current_user)

@app.route('/dashboard/manual-entry')
@login_required
def manual_entry():
    """Página para registro manual de sesiones (solo profesores)"""
    if not isinstance(current_user, Profesor):
        return redirect(url_for('dashboard'))
    return render_template('manual_entry.html')

@app.route('/api/analytics')
@login_required
def get_analytics():
    """Analytics para profesor - solo sesiones registradas por él"""
    if not isinstance(current_user, Profesor):
        return jsonify({'success': False, 'message': 'Solo para profesores'}), 403
    
    try:
        # Obtener sesiones registradas por este profesor
        sesiones = Sesion.query.filter_by(profesor_id=current_user.id).all()
        
        if not sesiones:
            return jsonify({
                'message': 'No hay datos disponibles',
                'estadisticas': {'general': {}},
                'por_maqueta': {},
                'correlaciones': {},
                'estudiantes_riesgo': [],
                'ranking': [],
                'clustering': {},
                'prediccion': {},
                'insights': [],
                'visualizacion': {
                    'distribucion_puntajes': {},
                    'puntajes_por_maqueta': {},
                    'tiempos_por_maqueta': {},
                    'tendencia_temporal': {'fechas': [], 'puntajes': []},
                    'scatter_tiempo_puntaje': {'tiempo': [], 'puntaje': [], 'maqueta': []}
                },
                'ml_clasificacion': {'modelo_disponible': False},
                'ml_clustering': {},
                'ml_correlaciones': {'disponible': False}
            }), 200
        
        # Usar analizador avanzado
        analizador = AnalizadorAvanzado(sesiones)
        
        analytics = {
            'estadisticas': analizador.estadisticas_descriptivas(),
            'por_maqueta': analizador.analisis_por_maqueta(),
            'correlaciones': analizador.correlaciones_avanzadas(),
            'estudiantes_riesgo': analizador.estudiantes_en_riesgo(),
            'ranking': analizador.ranking_estudiantes(),
            'clustering': analizador.clustering_estudiantes(n_clusters=3),
            'prediccion': analizador.prediccion_rendimiento(),
            'insights': analizador.generar_insights(),
            'visualizacion': analizador.datos_para_visualizacion(),
            # NUEVOS MÉTODOS ML PROFESIONALES
            'ml_clasificacion': analizador.clasificacion_binaria_aprobacion(),
            'ml_clustering': analizador.kmeans_clustering_profesional(n_clusters=3),
            'ml_correlaciones': analizador.correlaciones_con_pvalues()
        }
        
        return jsonify(analytics)
    except Exception as e:
        import traceback
        print("Error en analytics:", str(e))
        print(traceback.format_exc())
        return jsonify({
            'error': str(e),
            'message': 'Error al procesar los datos',
            'estadisticas': {'general': {}},
            'por_maqueta': {},
            'correlaciones': {},
            'estudiantes_riesgo': [],
            'ranking': [],
            'clustering': {},
            'prediccion': {},
            'insights': [],
            'visualizacion': {
                'distribucion_puntajes': {},
                'puntajes_por_maqueta': {},
                'tiempos_por_maqueta': {},
                'tendencia_temporal': {'fechas': [], 'puntajes': []},
                'scatter_tiempo_puntaje': {'tiempo': [], 'puntaje': [], 'maqueta': []}
            }
        }), 200

@app.route('/api/estudiantes', methods=['GET', 'POST'])
@login_required
def estudiantes():
    """Endpoint para gestionar estudiantes del profesor"""
    if not isinstance(current_user, Profesor):
        return jsonify({'success': False, 'message': 'Solo para profesores'}), 403
    
    if request.method == 'POST':
        data = request.json
        
        # Verificar si el estudiante ya existe
        estudiante_existente = Estudiante.query.filter_by(codigo=data['codigo']).first()
        
        if estudiante_existente:
            # Si existe, solo crear la relación si no está inscrito
            if current_user not in estudiante_existente.profesores:
                estudiante_existente.profesores.append(current_user)
                db.session.commit()
                return jsonify({'success': True, 'id': estudiante_existente.id, 'existente': True})
            else:
                return jsonify({'success': False, 'message': 'El estudiante ya está inscrito contigo'}), 400
        
        # Crear nuevo estudiante
        estudiante = Estudiante(
            nombre=data['nombre'],
            codigo=data['codigo'],
            email=data.get('email', '')
        )
        
        try:
            db.session.add(estudiante)
            db.session.flush()  # Para obtener el ID
            
            # Crear la relación con el profesor
            estudiante.profesores.append(current_user)
            db.session.commit()
            return jsonify({'success': True, 'id': estudiante.id, 'existente': False})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'message': 'Error al crear estudiante'}), 400
    
    # GET: Listar estudiantes del profesor
    mis_estudiantes = []
    for estudiante in current_user.estudiantes:
        # Contar sesiones donde este profesor registró datos
        sesiones_profesor = Sesion.query.filter_by(
            estudiante_id=estudiante.id,
            profesor_id=current_user.id
        ).count()
        
        mis_estudiantes.append({
            'id': estudiante.id,
            'nombre': estudiante.nombre,
            'codigo': estudiante.codigo,
            'email': estudiante.email,
            'total_sesiones': sesiones_profesor
        })
    
    return jsonify(mis_estudiantes)

# API para registro manual de sesiones (para profesores)
@app.route('/api/session/manual', methods=['POST'])
@login_required
def register_session_manual():
    """Endpoint para que profesores registren sesiones manualmente"""
    # Verificar que el usuario sea profesor
    if not isinstance(current_user, Profesor):
        return jsonify({'success': False, 'message': 'Solo profesores pueden registrar sesiones manualmente'}), 403
    
    data = request.json
    
    # Validar puntaje (escala 1-5)
    puntaje = float(data.get('puntaje', 0))
    if puntaje < 1 or puntaje > 5:
        return jsonify({'success': False, 'message': 'El puntaje debe estar entre 1 y 5'}), 400
    
    # Verificar que el estudiante esté inscrito con este profesor
    estudiante = Estudiante.query.get(data['estudiante_id'])
    
    if not estudiante or current_user not in estudiante.profesores:
        return jsonify({'success': False, 'message': 'Estudiante no encontrado o no está inscrito contigo'}), 404
    
    try:
        sesion = Sesion(
            estudiante_id=estudiante.id,
            profesor_id=current_user.id,  # Marcar que esta sesión fue registrada por este profesor
            maqueta=data['maqueta'],
            tiempo_segundos=data['tiempo_segundos'],
            puntaje=puntaje,
            interacciones_ia=data.get('interacciones_ia', 0),
            respuestas_detalle=json.dumps(data.get('respuestas', [])),
            fecha=datetime.utcnow()
        )
        
        db.session.add(sesion)
        db.session.commit()
        
        return jsonify({'success': True, 'session_id': sesion.id, 'message': 'Sesión registrada exitosamente'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Error al registrar sesión: {str(e)}'}), 400

# API para listar profesores (para estudiantes que se registran)
@app.route('/api/profesores', methods=['GET'])
def listar_profesores():
    """Lista todos los profesores para que estudiantes puedan inscribirse"""
    profesores = Profesor.query.all()
    return jsonify([{
        'id': p.id,
        'nombre': p.nombre,
        'email': p.email,
        'institucion': p.institucion
    } for p in profesores])

# API para obtener todas las sesiones del profesor (para filtro por maqueta)
@app.route('/api/sesiones-todas')
@login_required
def obtener_sesiones_todas():
    """Obtiene todas las sesiones registradas por el profesor actual"""
    if not isinstance(current_user, Profesor):
        return jsonify({'success': False, 'message': 'Solo profesores pueden acceder'}), 403
    
    # Obtener sesiones filtradas por profesor_id
    sesiones = Sesion.query.filter_by(profesor_id=current_user.id).all()
    
    return jsonify({
        'sesiones': [{
            'id': s.id,
            'estudiante_nombre': s.estudiante.nombre,
            'estudiante_codigo': s.estudiante.codigo,
            'maqueta': s.maqueta,
            'puntaje': s.puntaje,
            'tiempo_segundos': s.tiempo_segundos,
            'interacciones_ia': s.interacciones_ia,
            'fecha': s.fecha.isoformat()
        } for s in sesiones]
    })

# ============================================
# APIs ESPECÍFICAS PARA ESTUDIANTES
# ============================================

@app.route('/api/estudiante/analytics', methods=['GET'])
@login_required
def estudiante_analytics():
    """Analytics personales para el estudiante logueado"""
    if not isinstance(current_user, Estudiante):
        return jsonify({'success': False, 'message': 'Solo para estudiantes'}), 403
    
    # Obtener todas las sesiones del estudiante
    sesiones = current_user.sesiones
    
    if not sesiones:
        return jsonify({
            'success': True,
            'total_sesiones': 0,
            'estadisticas': {},
            'progreso_temporal': {'fechas': [], 'puntajes': []},
            'por_maqueta': {},
            'insights': ['No tienes sesiones registradas aún. ¡Comienza a practicar!']
        })
    
    # Crear DataFrame para análisis
    datos = []
    for s in sesiones:
        datos.append({
            'puntaje': s.puntaje,
            'tiempo_segundos': s.tiempo_segundos,
            'maqueta': s.maqueta,
            'fecha': s.fecha,
            'interacciones_ia': s.interacciones_ia
        })
    
    df = pd.DataFrame(datos)
    
    # Estadísticas generales
    stats = {
        'puntaje_promedio': float(df['puntaje'].mean()),
        'puntaje_maximo': float(df['puntaje'].max()),
        'puntaje_minimo': float(df['puntaje'].min()),
        'tiempo_promedio_minutos': float(df['tiempo_segundos'].mean() / 60),
        'total_interacciones_ia': int(df['interacciones_ia'].sum()),
        'sesiones_completadas': len(sesiones)
    }
    
    # Progreso temporal
    df_sorted = df.sort_values('fecha')
    progreso = {
        'fechas': [d.strftime('%Y-%m-%d') for d in df_sorted['fecha']],
        'puntajes': df_sorted['puntaje'].tolist()
    }
    
    # Análisis por maqueta
    por_maqueta = {}
    for maqueta in df['maqueta'].unique():
        df_maqueta = df[df['maqueta'] == maqueta]
        por_maqueta[maqueta] = {
            'sesiones': len(df_maqueta),
            'puntaje_promedio': float(df_maqueta['puntaje'].mean()),
            'mejor_puntaje': float(df_maqueta['puntaje'].max()),
            'tiempo_promedio': float(df_maqueta['tiempo_segundos'].mean())
        }
    
    # Insights personalizados
    insights = []
    
    # Tendencia de mejora
    if len(df) >= 3:
        primeras_3 = df_sorted.head(3)['puntaje'].mean()
        ultimas_3 = df_sorted.tail(3)['puntaje'].mean()
        mejora = ultimas_3 - primeras_3
        
        if mejora > 5:
            insights.append(f'¡Excelente! Has mejorado {mejora:.1f} puntos en promedio')
        elif mejora < -5:
            insights.append(f'Tus últimas sesiones bajaron {abs(mejora):.1f} puntos. ¡Sigue practicando!')
        else:
            insights.append('Tu rendimiento se mantiene estable')
    
    # Mejor maqueta
    if len(por_maqueta) > 1:
        mejor_maqueta = max(por_maqueta.items(), key=lambda x: x[1]['puntaje_promedio'])
        insights.append(f'Tu mejor maqueta es "{mejor_maqueta[0]}" con {mejor_maqueta[1]["puntaje_promedio"]:.1f} puntos')
    
    # Uso de IA
    if stats['total_interacciones_ia'] > 0:
        promedio_ia = stats['total_interacciones_ia'] / stats['sesiones_completadas']
        insights.append(f'Usas el asistente IA {promedio_ia:.1f} veces por sesión en promedio')
    
    # Serializar sesiones para el frontend (con información del profesor)
    sesiones_list = []
    for s in sesiones:
        profesor_info = None
        if s.profesor_id:
            profesor = Profesor.query.get(s.profesor_id)
            if profesor:
                profesor_info = {
                    'id': profesor.id,
                    'nombre': profesor.nombre
                }
        
        sesiones_list.append({
            'id': s.id,
            'maqueta': s.maqueta,
            'puntaje': s.puntaje,
            'tiempo_segundos': s.tiempo_segundos,
            'fecha': s.fecha.strftime('%Y-%m-%d %H:%M:%S'),
            'interacciones_ia': s.interacciones_ia,
            'profesor': profesor_info  # Agregar info del profesor
        })
    
    return jsonify({
        'success': True,
        'total_sesiones': len(sesiones),
        'sesiones': sesiones_list,  # Agregar sesiones completas
        'estadisticas': stats,
        'progreso_temporal': progreso,
        'por_maqueta': por_maqueta,
        'insights': insights
    })

@app.route('/api/estudiante/analytics-profesor/<int:profesor_id>', methods=['GET'])
@login_required
def estudiante_analytics_por_profesor(profesor_id):
    """Analytics del estudiante filtrados por un profesor específico"""
    if not isinstance(current_user, Estudiante):
        return jsonify({'success': False, 'message': 'Solo para estudiantes'}), 403
    
    # Verificar que el estudiante esté inscrito con este profesor
    profesor = Profesor.query.get(profesor_id)
    if not profesor:
        return jsonify({'success': False, 'message': 'Profesor no encontrado'}), 404
    
    if current_user not in profesor.estudiantes:
        return jsonify({'success': False, 'message': 'No estás inscrito con este profesor'}), 403
    
    # Obtener solo las sesiones registradas por este profesor
    sesiones = Sesion.query.filter_by(
        estudiante_id=current_user.id,
        profesor_id=profesor_id
    ).all()
    
    if not sesiones:
        return jsonify({
            'success': True,
            'profesor': {
                'id': profesor.id,
                'nombre': profesor.nombre,
                'institucion': profesor.institucion
            },
            'total_sesiones': 0,
            'sesiones': [],
            'estadisticas': {},
            'progreso_temporal': {'fechas': [], 'puntajes': []},
            'por_maqueta': {},
            'insights': [f'No tienes sesiones registradas con el profesor {profesor.nombre} aún']
        })
    
    # Análisis similar al endpoint general pero filtrado por profesor
    datos = []
    sesiones_list = []
    for s in sesiones:
        datos.append({
            'puntaje': s.puntaje,
            'tiempo_segundos': s.tiempo_segundos,
            'maqueta': s.maqueta,
            'fecha': s.fecha,
            'interacciones_ia': s.interacciones_ia
        })
        sesiones_list.append({
            'id': s.id,
            'maqueta': s.maqueta,
            'puntaje': s.puntaje,
            'tiempo_segundos': s.tiempo_segundos,
            'fecha': s.fecha.strftime('%Y-%m-%d %H:%M:%S'),
            'interacciones_ia': s.interacciones_ia,
            'profesor': {
                'id': profesor.id,
                'nombre': profesor.nombre
            }
        })
    
    df = pd.DataFrame(datos)
    
    # Estadísticas
    stats = {
        'puntaje_promedio': float(df['puntaje'].mean()),
        'puntaje_maximo': float(df['puntaje'].max()),
        'puntaje_minimo': float(df['puntaje'].min()),
        'tiempo_promedio_minutos': float(df['tiempo_segundos'].mean() / 60),
        'total_interacciones_ia': int(df['interacciones_ia'].sum()),
        'sesiones_completadas': len(sesiones)
    }
    
    # Progreso temporal
    df_sorted = df.sort_values('fecha')
    progreso = {
        'fechas': [d.strftime('%Y-%m-%d') for d in df_sorted['fecha']],
        'puntajes': df_sorted['puntaje'].tolist()
    }
    
    # Análisis por maqueta
    por_maqueta = {}
    for maqueta in df['maqueta'].unique():
        df_maqueta = df[df['maqueta'] == maqueta]
        por_maqueta[maqueta] = {
            'sesiones': len(df_maqueta),
            'puntaje_promedio': float(df_maqueta['puntaje'].mean()),
            'mejor_puntaje': float(df_maqueta['puntaje'].max()),
            'tiempo_promedio': float(df_maqueta['tiempo_segundos'].mean())
        }
    
    insights = [f'Sesiones con el profesor {profesor.nombre}']
    
    return jsonify({
        'success': True,
        'profesor': {
            'id': profesor.id,
            'nombre': profesor.nombre,
            'institucion': profesor.institucion
        },
        'total_sesiones': len(sesiones),
        'sesiones': sesiones_list,
        'estadisticas': stats,
        'progreso_temporal': progreso,
        'por_maqueta': por_maqueta,
        'insights': insights
    })

@app.route('/api/estudiante/inscribirse', methods=['POST'])
@login_required
def estudiante_inscribirse():
    """Permite al estudiante inscribirse con un profesor (soporta múltiples profesores)"""
    if not isinstance(current_user, Estudiante):
        return jsonify({'success': False, 'message': 'Solo para estudiantes'}), 403
    
    data = request.json
    profesor_id = data.get('profesor_id')
    
    if not profesor_id:
        return jsonify({'success': False, 'message': 'ID de profesor requerido'}), 400
    
    profesor = Profesor.query.get(profesor_id)
    if not profesor:
        return jsonify({'success': False, 'message': 'Profesor no encontrado'}), 404
    
    # Verificar si ya está inscrito con este profesor
    if current_user in profesor.estudiantes:
        return jsonify({
            'success': False,
            'message': f'Ya estás inscrito con {profesor.nombre}',
            'ya_inscrito': True
        }), 400
    
    # Agregar relación con el profesor
    profesor.estudiantes.append(current_user)
    
    try:
        db.session.commit()
        
        # Contar profesores actuales
        total_profesores = current_user.profesores.count()
        
        return jsonify({
            'success': True,
            'message': f'Te has inscrito exitosamente con {profesor.nombre}',
            'total_profesores': total_profesores,
            'profesor': {
                'id': profesor.id,
                'nombre': profesor.nombre,
                'email': profesor.email,
                'institucion': profesor.institucion
            }
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'Error al inscribirse: {str(e)}'}), 400

@app.route('/api/estudiante/profesores', methods=['GET'])
@login_required
def estudiante_profesores():
    """Lista de profesores con los que el estudiante está inscrito o disponibles"""
    if not isinstance(current_user, Estudiante):
        return jsonify({'success': False, 'message': 'Solo para estudiantes'}), 403
    
    # Profesores con los que está inscrito
    mis_profesores = []
    for profesor in current_user.profesores:
        # Contar sesiones con este profesor
        sesiones_con_profesor = Sesion.query.filter_by(
            estudiante_id=current_user.id,
            profesor_id=profesor.id
        ).count()
        
        mis_profesores.append({
            'id': profesor.id,
            'nombre': profesor.nombre,
            'email': profesor.email,
            'institucion': profesor.institucion,
            'total_sesiones': sesiones_con_profesor,
            'inscrito': True
        })
    
    # Todos los profesores disponibles
    todos_profesores = Profesor.query.all()
    profesores_ids_inscritos = {p.id for p in current_user.profesores}
    
    profesores_disponibles = []
    for p in todos_profesores:
        profesores_disponibles.append({
            'id': p.id,
            'nombre': p.nombre,
            'email': p.email,
            'institucion': p.institucion,
            'inscrito': p.id in profesores_ids_inscritos
        })
    
    return jsonify({
        'success': True,
        'mis_profesores': mis_profesores,
        'total_profesores_inscritos': len(mis_profesores),
        'profesores_disponibles': profesores_disponibles
    })

# API para Unity - Registro de sesiones
@app.route('/api/unity/session', methods=['POST'])
def register_session():
    """Endpoint para que Unity envíe los datos de las sesiones"""
    data = request.json
    
    # Verificar que el estudiante existe
    estudiante = Estudiante.query.filter_by(codigo=data['codigo_estudiante']).first()
    if not estudiante:
        return jsonify({'success': False, 'message': 'Estudiante no encontrado'}), 404
    
    sesion = Sesion(
        estudiante_id=estudiante.id,
        maqueta=data['maqueta'],
        tiempo_segundos=data['tiempo_segundos'],
        puntaje=data['puntaje'],
        interacciones_ia=data.get('interacciones_ia', 0),
        respuestas_detalle=json.dumps(data.get('respuestas', []))
    )
    
    db.session.add(sesion)
    db.session.commit()
    
    return jsonify({'success': True, 'session_id': sesion.id})

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)